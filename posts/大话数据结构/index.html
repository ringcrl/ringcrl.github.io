<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="大话数据结构" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="大话数据结构" /><meta property="og:description" content="大话数据结构" /><link rel="canonical" href="chenng.cn/posts/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><meta property="og:url" content="chenng.cn/posts/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><meta property="og:site_name" content="Chenng’s Home" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-07-10T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="大话数据结构" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-07-10T00:00:00+08:00","datePublished":"2018-07-10T00:00:00+08:00","description":"大话数据结构","headline":"大话数据结构","mainEntityOfPage":{"@type":"WebPage","@id":"chenng.cn/posts/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"url":"chenng.cn/posts/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}</script><title>大话数据结构 | Chenng's Home</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chenng's Home"><meta name="application-name" content="Chenng's Home"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn-1257430323.cos.ap-guangzhou.myqcloud.com/assets/imgs/20210506201457_0026033cb6769057453d0142751005ae.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Chenng's Home</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ringcrl" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ringcrl','foxmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>大话数据结构</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>大话数据结构</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> chenng </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 10, 2018, 12:00 AM +0800" prep="on" > Jul 10, 2018 <i class="unloaded">2018-07-10T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6250 words">34 min</span></div></div><div class="post-content"><h1 id="大话数据结构">大话数据结构</h1><hr /><h2 id="数据结构">数据结构</h2><ul><li>数据结构就是以某种特定的布局存储数据<li>这个布局使得某些操作非常高些，另外一些操作不那么高效<li>理解数据结构，就能为手头问题选择最优的数据结构</ul><hr /><h2 id="算法">算法</h2><p><strong>算法是解决特定问题求解步骤的描述</strong></p><hr /><h2 id="存储结构">存储结构</h2><ul><li><p>顺序存储结构</p><ul><li>在内存地址中连续存储<li>建立定长数组，计算机在内存中开辟连续空间</ul><li><p>链式存储结构</p><ul><li>存储单元可连续可不连续，存放的是指针地址，通过地址就能找到关联数据<li>单线联系，断了就找不到了</ul></ul><p></p><hr /><h2 id="数组">数组</h2><ul><li><p>误区</p><ul><li>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)，即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)<li>正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</ul><li><p>数组下标为什么从 0 开始</p><ul><li>从数组存储的内存模型上来看，下标最确切的定义应该是偏移（offset）<li>如果用 a 来表示数组的首地址，<code class="language-plaintext highlighter-rouge">a[0]</code> 就是偏移为 0 的位置，也就是首地址，<code class="language-plaintext highlighter-rouge">a[k]</code> 就表示偏移 k 个 type_size 的位置：<code class="language-plaintext highlighter-rouge">a[k]_address = base_address + k * type_size</code></ul></ul><hr /><h2 id="栈">栈</h2><ul><li><p>栈既可以用数组来实现，也可以用链表来实现</p><ul><li>用数组实现的栈，叫作顺序栈<li>用链表实现的栈，叫作链式栈</ul><li><p>应用</p><ul><li><code class="language-plaintext highlighter-rouge">Array.push</code> 和 <code class="language-plaintext highlighter-rouge">Array.pop</code> 就是栈，可以在线上直接使用，时间复杂度是 O(1)<li>浏览器前进后退、Blockly 的撤销重做，就是通过两个栈来做记录</ul></ul><hr /><h2 id="队列">队列</h2><ul><li><p>基本操作</p><ul><li>Enqueue() - 向队列末尾插入元素<li>Dequeue() - 从队列头部移除元素<li>isEmpty() - 如果队列为空，则返回 true<li>Top() - 返回队列的第一个元素</ul><li><p>JS 中的队列</p><ul><li><code class="language-plaintext highlighter-rouge">Array.shift</code> 出队的时间复杂度是 O(n)，线上项目不可直接使用（误），因此需要实现一个 <code class="language-plaintext highlighter-rouge">Queue</code> 队列，以实现 O(1) 的时间复杂度</ul></ul><hr /><h3 id="队列-js-实现">队列 JS 实现</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Queue</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">max</span><span class="p">);</span><span class="k">this</span><span class="p">.</span><span class="nx">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="k">this</span><span class="p">.</span><span class="nx">max</span> <span class="o">=</span> <span class="nx">max</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">enqueue</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">max</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// overflow</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">item</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// underflow</span>
    <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">q</span><span class="o">++</span><span class="p">];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">q</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="优先队列">优先队列</h3><ul><li>优先级最高的元素优先出队，实现是入队时插入到对的位置<li>测试用例</ul><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">PriorityQueue</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">../PriorityQueue</span><span class="dl">"</span><span class="p">);</span>

<span class="nf">describe</span><span class="p">(</span><span class="dl">"</span><span class="s2">PriorityQueue</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">enqueue</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">priorityQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="p">();</span>
    <span class="nx">priorityQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nx">priorityQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">Jack</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nx">priorityQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">Camila</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="nf">expect</span><span class="p">(</span><span class="nx">priorityQueue</span><span class="p">.</span><span class="nf">print</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">3-Camila-&gt;2-John-&gt;1-Jack</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></table></code></div></div><hr /><p>优先队列核心逻辑</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>  <span class="nf">enqueue</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">queueElement</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueueElement</span><span class="p">(</span>
      <span class="nx">element</span><span class="p">,</span>
      <span class="nx">priority</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="kd">let</span> <span class="nx">added</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">queueElement</span><span class="p">.</span><span class="nx">priority</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">queueElement</span><span class="p">);</span>
        <span class="nx">added</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">added</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">queueElement</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="链表">链表</h2><ul><li><p>数组中插入或者移除项的成本过高</p><ul><li>splice(start, deleteCount, item1, item2, …) 时间复杂度 O(n)</ul><li><p>在链表中删除数据</p><ul><li>删除结点中“值等于某个给定值”的结点，从头开始遍历，查找的时间复杂度是 O(n)<li>删除给定指针指向的结点，双链表因为保存了前驱和后驱指针，所以只需要 O(1) 的时间复杂度</ul></ul><hr /><p>链表的用法一</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">append</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">1-&gt;2-&gt;3-&gt;4-&gt;5</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">insert</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">1-&gt;4-&gt;2-&gt;3</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</pre></table></code></div></div><hr /><p>链表的用法二</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">removeAt</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">removeAt</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">1-&gt;2-&gt;3-&gt;5</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">remove</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">1-&gt;2-&gt;4-&gt;5</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</pre></table></code></div></div><hr /><p>链表的用法三</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">indexOf</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nf">toBe</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">});</span>

<span class="nf">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">reverse</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="p">();</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="nx">list</span><span class="p">.</span><span class="nf">reverse</span><span class="p">();</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">"</span><span class="s2">5-&gt;4-&gt;3-&gt;2-&gt;1</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</pre></table></code></div></div><hr /><h3 id="链表的数据结构">链表的数据结构</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// 链表项</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 链表容器</span>
<span class="kd">class</span> <span class="nc">LinkedList</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="插入操作图示">插入操作图示</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/02.jpg" alt="02.jpg" /></p><hr /><h3 id="插入操作代码">插入操作代码</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="nf">append</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">curr</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">curr</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
  <span class="c1">// 循环找到列表的最后一项</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="反转链表">反转链表</h3><ul><li>画图帮助理解<li>训练解决多个链接关系的思路、例如爬楼梯问题</ul><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nf">reverse</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">curr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">;</span>
    <span class="nx">prev</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">;</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="双向链表图示">双向链表图示</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/01.jpg" alt="01.jpg" /></p><hr /><h3 id="双向链表数据结构">双向链表数据结构</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 比单链表多出来的属性</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">DoublyLinkedList</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 比单链表多出来的属性</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="散列表">散列表</h2><ul><li>散列表又称为哈希表<li>散列表表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来，如果没有数组，就没有散列表<li>散列表是动态集合结构中查找一个元素时间最短的</ul><hr /><h3 id="散列表性能">散列表性能</h3><ul><li>散列函数<li>散列表的大小<li>碰撞处理方法</ul><hr /><h3 id="散列函数">散列函数</h3><p>散列函数可以定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值:</p><ul><li>散列函数计算得到的散列值是一个非负整数, 因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数<li>如果 key1 = key2，那 hash(key1) == hash(key2)<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</ul><hr /><h3 id="散列表数据结构">散列表数据结构</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">HashTable</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">table</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>

  <span class="nf">djb2HashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">hash</span> <span class="o">=</span> <span class="mi">5381</span><span class="p">;</span> <span class="c1">// 一个较大的素数基准值</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">hash</span> <span class="o">=</span> <span class="nx">hash</span> <span class="o">*</span> <span class="mi">33</span> <span class="o">+</span> <span class="nx">key</span><span class="p">.</span><span class="nf">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">hash</span> <span class="o">%</span> <span class="mi">1013</span><span class="p">;</span> <span class="c1">// 除以1013取余</span>
  <span class="p">}</span>

  <span class="nf">put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{}</span>

  <span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{}</span>

  <span class="nf">remove</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="散列冲突解决">散列冲突解决</h3><ul><li>更好的散列函数<ul><li>一个表现良好的散列函数应该有较好的插入和查找性能且有较低的冲突可能性</ul><li>线性探查<ul><li>线性探查法在向散列表中插入元素时，如果插入位置 position 已经被占据，就尝试插入 position+1 的位置，以此类推，直到找到空的位置</ul><li>链表法<ul><li>在散列表中，每个桶（bucket）或者槽（slot）会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中<li>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)</ul></ul><hr /><h2 id="布隆过滤器">布隆过滤器</h2><ul><li>判断假永远是假，真不一定是真<li>原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想<li>我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多</ul><hr /><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter/BloomFilter.js">布隆过滤器实现</a></p><hr /><h2 id="树">树</h2><h3 id="基本概念">基本概念</h3><ul><li>节点：树中的每个元素都叫做节点<li>根节点：位于树顶顶部的节点，它没有父节点<li>内部节点：至少有一个子节点的节点<li>叶子节点：没有子元素的节点<li>高度：从 0 开始，根节点最高<li>深度：从 0 开始，根节点为 0<li>层数：从 1 开始，根节点为 1<li>满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。<li>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</ul><hr /><h3 id="高度深度层数">高度、深度、层数</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/03.png" alt="03.png" /></p><hr /><h3 id="满二叉树完全二叉树">满二叉树、完全二叉树</h3><p>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/04.png" alt="04.png" /></p><hr /><h3 id="二叉树的遍历">二叉树的遍历</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/05.png" alt="05.png" /></p><hr /><p>前序遍历：根 =&gt; 左 =&gt; 右</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">preOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="nf">preOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)).</span><span class="nf">concat</span><span class="p">(</span><span class="nf">preOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>中序遍历：左 =&gt; 根 =&gt; 右</p><p>如果是二叉查找树，得到的就是有序的数据</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">inOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">inOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">).</span><span class="nf">concat</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">).</span><span class="nf">concat</span><span class="p">(</span><span class="nf">inOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>后序遍历：左 =&gt; 右 =&gt; 根</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">postOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">postOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">).</span><span class="nf">concat</span><span class="p">(</span><span class="nf">postOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)).</span><span class="nf">concat</span><span class="p">([</span><span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="二叉查找树">二叉查找树</h3><ul><li>实现 O(logn) 的查找效率<li>别称：二叉搜索树、有序二叉树、排序二叉树<li>左子树上所有节点的值均小于它的根节点的值<li>右子树上所有节点的值均大于它的根节点的值<li>左右子树也分别为二叉查找树</ul><hr /><h4 id="二叉查找树数据结构">二叉查找树数据结构</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// 节点</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 树</span>
<span class="kd">class</span> <span class="nc">BinarySearchTree</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 和 LinkedList 类似，不过这里是根元素，不是头节点</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---插入">二叉查找树 - 插入</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nf">_insertNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">_insertNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">_insertNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---查找一个-key-是否存在">二叉查找树 - 查找一个 key 是否存在</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nf">_searchNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">_searchNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">_searchNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---中序遍历">二叉查找树 - 中序遍历</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nf">_inOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nf">_inOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
  <span class="nf">cb</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">_inOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---先序遍历">二叉查找树 - 先序遍历</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nf">_preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">cb</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">_preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">_preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---后序遍历">二叉查找树 - 后序遍历</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nf">_postOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cb</span><span class="p">){</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nf">_postOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">_postOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span>
  <span class="nf">cb</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---返回树中最小值">二叉查找树 - 返回树中最小值</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nf">_minNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">node</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---返回树中最大值键">二叉查找树 - 返回树中最大值/键</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nf">_maxNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">node</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---从树中移除某个键">二叉查找树 - 从树中移除某个键</h4><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="nf">_removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">_removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span> <span class="c1">// 给父节点提供指针指向</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">_removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span> <span class="c1">// 给父节点提供指针指向</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="cm">/**
       * 如果找到了 key === node.key，就要处理三种情况
       * 1. 叶子节点
       * 2. 只有左节点或者只有右节点的节点
       * 3. 有两个子节点的节点
      */</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h4 id="二叉查找树---从树中移除某个键-1">二叉查找树 - 从树中移除某个键</h4><p><a href="https://static.chenng.cn/#/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95?id=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">_removeNode 完整代码</a></p><hr /><h4 id="二叉查找树---支持重复数据的两种方法">二叉查找树 - 支持重复数据的两种方法</h4><ul><li>二叉查找树中每一个节点不仅会存储一个数据，会通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上<li>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来</ul><hr /><h4 id="二叉树查找树与散列表对比">二叉树查找树与散列表对比</h4><ul><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序；而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列（<a href="./imgs/06.png">06.png</a>）<li><ul><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)</ul><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定</ul><hr /><h3 id="平衡二叉树">平衡二叉树</h3><ul><li>二叉树中任意一个节点的左右子树的高度相差不能大于 1<li>完全二叉树、满二叉树其实都是平衡二叉树<li>非完全二叉树也有可能是平衡二叉树</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/07.png" alt="07.png" /></p><p>极度不平衡的时候查找的复杂度就是 O(n) 了</p><hr /><h3 id="堆">堆</h3><ul><li>堆是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值<li>堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值<li>堆排序的时间复杂度是 O(n)</ul><hr /><h4 id="堆的使用">堆的使用</h4><ul><li>优先级队列<ul><li>堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素</ul><li>利用堆求 Top K<ul><li>每次询问前 K 大数据，我们都基于当前的数据重新排序的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小<li>可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比</ul></ul><hr /><h4 id="堆的实现">堆的实现</h4><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/README.zh-CN.md">javascript-algorithms-heap</a></p><hr /><h3 id="b-树">B+ 树</h3><p>该用什么数据结构实现下面的查找需求？</p><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">-- 根据某个值查找数据</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1234</span>

<span class="c1">-- 根据区间值来查找某些数据</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">1234</span> <span class="k">and</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">2345</span>
</pre></table></code></div></div><hr /><h4 id="mysql-的查找需求">Mysql 的查找需求：</h4><ul><li>散列表：查询性能很好，时间复杂度是 O(1)，散列表不能支持按照区间快速查找数据<li>平衡二叉查找树：查询的时间复杂度是 O(logn)，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这不足以支持按照区间快速查找数据</ul><hr /><h4 id="改造二叉查找树">改造二叉查找树</h4><ul><li>让二叉查找树支持按照区间来查找数据<li>树中的节点并不存储数据本身，而是只是作为索引<li>把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的</ul><hr /><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/08.jpeg" alt="二叉查找树" /></p><hr /><h4 id="使用-b-树">使用 B+ 树</h4><ul><li>我们只需要拿区间的起始值，在树中进行查找<li>当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止<li>所有遍历到的数据，就是符合区间值的所有数据</ul><hr /><h2 id="数据结构练习---leetcode">数据结构练习 - Leetcode</h2><ul><li>数组和链表<li>栈、队列和递归<li>排序和二分查找<li>散列表和字符串<li>二叉树和堆<li>贪心、分治、回溯和动态规划</ul><hr /><h3 id="数组和链表">数组和链表</h3><ul><li><a href="https://leetcode.com/problems/3sum/">Three Sum（求三数之和）</a><li><a href="https://leetcode.com/problems/majority-element/">Majority Element（求众数）</a><li><a href="https://leetcode.com/problems/first-missing-positive/">Missing Positive（求缺失的第一个正数）</a><li><a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle I（环形链表）</a><li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Merge k Sorted Lists（合并 k 个排序链表）</a></ul><hr /><h3 id="栈队列和递归">栈、队列和递归</h3><ul><li><a href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses（有效的括号）</a><li><a href="https://leetcode.com/problems/longest-valid-parentheses/">Longest Valid Parentheses（最长有效的括号）</a><li><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">Evaluate Reverse Polish Notatio（逆波兰表达式求值）</a><li><a href="https://leetcode.com/problems/design-circular-deque/">Design Circular Deque（设计一个双端队列）</a><li><a href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window Maximum（滑动窗口最大值）</a><li><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs（爬楼梯）</a></ul><hr /><h3 id="排序和二分查找">排序和二分查找</h3><ul><li>实现归并排序、快速排序、插入排序、冒泡排序、选择排序<li>实现 O(n) 时间复杂度内找到一组数据的第 K 大元素<li><a href="https://leetcode.com/problems/sqrtx/">Sqrt(x) （x 的平方根）</a></ul><hr /><h3 id="散列表和字符串">散列表和字符串</h3><ul><li><a href="https://www.codewars.com/kata/53b406e67040e51e17000c0a">实现一个 LRU 缓存淘汰算法</a><li><a href="https://leetcode.com/problems/reverse-string/">Reverse String （反转字符串）</a><li><a href="https://leetcode.com/problems/reverse-words-in-a-string/">Reverse Words in a String（翻转字符串里的单词）</a><li><a href="https://leetcode.com/problems/string-to-integer-atoi/">String to Integer (atoi)（字符串转换整数 (atoi)）</a></ul><hr /><h3 id="二叉树和堆">二叉树和堆</h3><ul><li><a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree（翻转二叉树）</a><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree（二叉树的最大深度）</a><li><a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree（验证二叉查找树）</a><li><a href="https://leetcode.com/problems/path-sum/">Path Sum（路径总和）</a></ul><hr /><h3 id="贪心分治回溯和动态规划">贪心、分治、回溯和动态规划</h3><ul><li><a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum（最小路径和）</a><li><a href="https://leetcode.com/problems/coin-change/">Coin Change （零钱兑换）</a><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock（买卖股票的最佳时机）</a><li><a href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product Subarray（乘积最大子序列）</a><li><a href="https://leetcode.com/problems/triangle/">Triangle（三角形最小路径和）</a></ul><hr /><h2 id="数据结构练习---codewars">数据结构练习 - Codewars</h2><p><a href="https://www.codewars.com/kata/latest/my-languages"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/09.png" alt="09.png" /></a></p><hr /><p>前期针对性训练，后期订阅，把每周二邮件发来的热门题目做一下</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="./imgs/10.png" alt="10.png" /></p><hr /><h1 id="凑时间用的算法">凑时间用的算法</h1><p>如果到这里还有时间，就讲讲后面准备的一些凑时间用的算法实例吧</p><hr /><h2 id="二分查找">二分查找</h2><p>在排序数组中找到找到某个元素，懂得理论和写出代码还差了个卡死浏览器的操作</p><hr /><h3 id="二分查找---普通版">二分查找 - 普通版</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="二分查找---进阶版">二分查找 - 进阶版</h3><p>有一种玻璃小球，从一定高度丢下去撞到水泥地面上会撞碎。对于这种小球，摔碎的高度是一个固定值，高于这个值会摔碎，小于这个高度不会被摔碎。对于一栋 100 层的建筑，和两个小球，怎么操作最快试出临界层数？</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">findCriticalPoint</span><span class="p">(</span><span class="nx">heigh</span><span class="p">,</span> <span class="nx">remainNum</span><span class="p">,</span> <span class="nx">criticalPoint</span><span class="p">,</span> <span class="nx">currHeigh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">tryTimes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">remainNum</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">if </span><span class="p">(</span><span class="nx">remainNum</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">criticalPoint</span> <span class="o">===</span> <span class="nx">currHeigh</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">tryTimes</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">criticalPoint</span> <span class="o">&gt;</span> <span class="nx">currHeigh</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">findCriticalPoint</span><span class="p">(</span><span class="nx">heigh</span><span class="p">,</span> <span class="nx">remainNum</span><span class="p">,</span> <span class="nx">criticalPoint</span><span class="p">,</span> <span class="nx">currHeigh</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">tryTimes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

<span class="c1">// ...</span>
</pre></table></code></div></div><hr /><h2 id="斐波那契">斐波那契</h2><p>经典的的问题</p><h3 id="斐波那契---递归版本">斐波那契 - 递归版本</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">fibonacci</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h3 id="斐波那契---递推版本">斐波那契 - 递推版本</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">fibonaci</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">F</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">F</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">F</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">F</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">F</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">F</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">F</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h2 id="爬楼梯问题">爬楼梯问题</h2><p>楼梯台阶有 12 阶，一步只能走 1 阶或者 2 阶，那么，请问走完楼梯有多少走法？</p><hr /><p>动态规划的三个术语：</p><ul><li>最优子结构<li>边界<li>状态转移公式</ul><hr /><p>问题分析：</p><ul><li>走到最后一个台阶的前一个情况，只能有两种，就是从第 11 台阶走一步上来，或者从 10 台阶走两步上来，X 种走法走到了 11 阶，Y 种走法走到了 10 阶，走到 12 阶的走法一定是 X + Y，这就是【最优子结构】<li>走到第一个台阶，1 种走法，没有台阶，那就 0 种走法，走到第二个台阶，2 种走法，其实这就是【边界】<li>【状态转移公式】：F(n) = F(n-1) + F(n-2)</ul><hr /><p>爬楼梯问题 - 一般写法</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// 递归写法存在大量重复计算</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>
<span class="kd">function</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">stairs</span> <span class="o">=</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">map</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">stairs</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">stairs</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>爬楼梯问题 - 动态规划写法</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 动态规划版本</span>
<span class="kd">function</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">oneStepBefore</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">twoStepBefore</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">allWays</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">allWays</span> <span class="o">=</span> <span class="nx">oneStepBefore</span> <span class="o">+</span> <span class="nx">twoStepBefore</span><span class="p">;</span>
    <span class="nx">twoStepBefore</span> <span class="o">=</span> <span class="nx">oneStepBefore</span><span class="p">;</span>
    <span class="nx">oneStepBefore</span> <span class="o">=</span> <span class="nx">allWays</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">allWays</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h1 id="五种算法模式">五种算法模式</h1><ul><li>递归模式<li>DFS<li>BFS<li>二分查找<li>dp 方程</ul><hr /><h2 id="递归模式">递归模式</h2><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">recursion</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 递归终止条件</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">level</span> <span class="o">&gt;</span> <span class="nx">MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 打印结果</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 处理当前层级的逻辑</span>
  <span class="nf">processData</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>

  <span class="c1">// 递归</span>
  <span class="nf">recursion</span><span class="p">(</span><span class="nx">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">);</span>

  <span class="c1">// 如果需要，反向当前层级</span>
  <span class="nf">reverseState</span><span class="p">(</span><span class="nx">level</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="dfs">DFS</h2><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
<span class="kd">function</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>

  <span class="c1">// 处理当前的 node</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">child</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">dfs</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="bfs">BFS</h2><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
<span class="kd">function</span> <span class="nf">bfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
    <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>

    <span class="nf">process</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>

    <span class="nx">nodes</span> <span class="o">=</span> <span class="nf">generateRelatedNodes</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">nodes</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="二分查找-1">二分查找</h2><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nx">left</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">right</span> <span class="o">-</span> <span class="nx">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 防溢出</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="dp-方程">dp 方程</h2><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// 状态定义，创建二维数组</span>
<span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">`[</span><span class="p">${</span><span class="nx">i</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="nx">j</span><span class="p">}</span><span class="s2">]`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

<span class="c1">// 初始状态</span>
<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>

<span class="c1">// DP 状态推导</span>

<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">matchMedia</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="p">][</span><span class="nx">n</span><span class="p">];</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/2018/" class="post-tag no-text-decoration" >2018</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/2018/">2018</a> <a class="post-tag" href="/tags/2017/">2017</a> <a class="post-tag" href="/tags/2019/">2019</a> <a class="post-tag" href="/tags/2020/">2020</a> <a class="post-tag" href="/tags/2021/">2021</a> <a class="post-tag" href="/tags/2016/">2016</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALazy-Load/"><div class="card-body"> <span class="timeago small" > Feb 2, 2018 <i class="unloaded">2018-02-02T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>实现一个Lazy-Load</h3><div class="text-muted small"><p> 我们可以在页面打开的时候把首屏的图片资源加载出来，等用户滚动的时候再把页面其他部分呈现。 html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device...</p></div></div></a></div><div class="card"> <a href="/posts/JS%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"><div class="card-body"> <span class="timeago small" > Feb 3, 2018 <i class="unloaded">2018-02-03T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JS内存分析</h3><div class="text-muted small"><p> 使用 Chrome 和 DevTools 查找影响页面性能的内存问题 内存泄漏 内存膨胀 频繁的垃圾回收 内存问题 页面的性能随着时间的延长越来越差。 这可能是内存泄漏的症状。 内存泄漏是指，页面中的错误导致页面随着时间的延长使用的内存越来越多。 页面的性能一直很糟糕。 这可能是内存膨胀的症状。 内存膨胀是指，页面为达到最佳速度而使用的内存比本应使用的内存多。...</p></div></div></a></div><div class="card"> <a href="/posts/Web%E9%99%80%E8%9E%BA%E4%BB%AA%E4%B8%8E%E9%87%8D%E5%8A%9B%E6%84%9F%E5%BA%94/"><div class="card-body"> <span class="timeago small" > Mar 20, 2018 <i class="unloaded">2018-03-20T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Web陀螺仪与重力感应</h3><div class="text-muted small"><p> 陀螺仪与重力感应配置与注意点： API 使用 临界点处理 翻转处理 iOS 12.2 政策 devicemotion function init_devicemotion_listener() { if ((window as any).DeviceMotionEvent) { window.addEventListener('devicemotion'...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/JS%E6%8B%B7%E8%B4%9D/" class="btn btn-outline-primary" prompt="Older"><p>JS拷贝</p></a> <a href="/posts/%E4%BB%80%E4%B9%88%E6%98%AFMutator/" class="btn btn-outline-primary" prompt="Newer"><p>什么是Mutator</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/ringcrl">chenng</a>.<p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"> 粤ICP备18131461号 </a></p></p></div><div class="footer-right"></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/2018/">2018</a> <a class="post-tag" href="/tags/2017/">2017</a> <a class="post-tag" href="/tags/2019/">2019</a> <a class="post-tag" href="/tags/2020/">2020</a> <a class="post-tag" href="/tags/2021/">2021</a> <a class="post-tag" href="/tags/2016/">2016</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="chenng.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
