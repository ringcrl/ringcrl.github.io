<feed xmlns="http://www.w3.org/2005/Atom"> <id>chenng.cn/</id><title>Chenng's Home</title><subtitle>chenng,homepage</subtitle> <updated>2024-07-31T15:02:23+08:00</updated> <author> <name>chenng</name> <uri>chenng.cn/</uri> </author><link rel="self" type="application/atom+xml" href="chenng.cn/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="chenng.cn/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 chenng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>canvas像素对比测试用例</title><link href="chenng.cn/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E6%AF%94%E5%AF%B9%E6%96%B9%E6%A1%88/" rel="alternate" type="text/html" title="canvas像素对比测试用例" /><published>2021-05-06T00:00:00+08:00</published> <updated>2021-05-06T00:00:00+08:00</updated> <id>chenng.cn/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E6%AF%94%E5%AF%B9%E6%96%B9%E6%A1%88/</id> <content src="chenng.cn/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E6%AF%94%E5%AF%B9%E6%96%B9%E6%A1%88/" /> <author> <name>chenng</name> </author> <summary> 最近在做服务端 canvas-webgl 渲染，探索下怎么通过自动化的方案来保证渲染效果。 探索背景 网络上对 Canvas 的渲染测试用例方案归纳有三种： 方案一：Node 记录 Canvas 的 API 操作记录，验证执行，例如：jest-mock-canvas 方案二：真实浏览器渲染比对，例如 cypress 方案三：学习 Three.js 的 e2e 测试用例，使用 puppeteer 进行截图比对 方案一没有太大意义，因为服务端渲染业务逻辑是跟前端完全一致的，影响渲染效果在更底层的 C++ 模块 方案二需要开启浏览器验证，而我们的开发环境全是在容器中进行，没有可视化环境 方案三主要借助 pixelmatch 库实现像素级对比，提供了很好的解决思路 截取原图： 和原图进行对比： 单图比对 因为我们的渲染方案本身就是在服务端操作数据，... </summary> </entry> <entry><title>PS-AE-Sketch</title><link href="chenng.cn/posts/PS-AE-Sketch/" rel="alternate" type="text/html" title="PS-AE-Sketch" /><published>2021-04-30T00:00:00+08:00</published> <updated>2021-04-30T00:00:00+08:00</updated> <id>chenng.cn/posts/PS-AE-Sketch/</id> <content src="chenng.cn/posts/PS-AE-Sketch/" /> <author> <name>chenng</name> </author> <summary> PS 面板 主菜单【窗口】下开启的窗户，必备的是【属性】、【信息】、【图层】 选择图层 【cmd + 左键】 =&amp;gt; 选择图层 【option + 滚轮】 =&amp;gt; 放大缩小图像 属性面板 选择图层之后，可以再属性面板看到： 文本的字体大小和颜色 形状的填充色和圆角 智能对象的宽高 信息面板 有时候在【属性面板】不能看到图层的宽高信息，可以通过【cmd + T】打开操作变形，在信息面板就一定可以看到宽高了，看完后用【esc】退出 吸管工具 设计稿中有一些不太明显的渐变色背景色模块，按住左键拖动吸管，观察信息面板就知道用【background-color】还是【linear-gradient】了 右键需要获取的颜色点，可以通过【拷贝颜色的十六进制代码】快速获得 CSS 的属性值 图层有不透明度，需要先恢复到 100%... </summary> </entry> <entry><title>WebCodecs对音视频进行编码解码</title><link href="chenng.cn/posts/WebCodecs%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/" rel="alternate" type="text/html" title="WebCodecs对音视频进行编码解码" /><published>2020-10-19T00:00:00+08:00</published> <updated>2020-10-19T00:00:00+08:00</updated> <id>chenng.cn/posts/WebCodecs%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/</id> <content src="chenng.cn/posts/WebCodecs%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/" /> <author> <name>chenng</name> </author> <summary> WebCodecs 草案：https://wicg.github.io/web-codecs/ Github：https://github.com/WICG/web-codecs 允许 Web 应用程序对音频和视频进行编码和解码的 API 在 Chrome &amp;gt;= 86 的版本进行体验 Chrome地址栏输入：chrome://flags/#enable-experimental-web-platform-features，设置成 Enabled 通过命令行启用 Chrome：/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --enable-blink-features=WebCodecs // 通过 VideoEncoder API 检查当前浏览器是否支持 if ('... </summary> </entry> <entry><title>通过babel-plugin校验封装第三方提供的vue组件</title><link href="chenng.cn/posts/%E9%80%9A%E8%BF%87babel-plugin%E6%A0%A1%E9%AA%8C%E5%B0%81%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84vue%E7%BB%84%E4%BB%B6/" rel="alternate" type="text/html" title="通过babel-plugin校验封装第三方提供的vue组件" /><published>2020-05-10T00:00:00+08:00</published> <updated>2020-05-10T00:00:00+08:00</updated> <id>chenng.cn/posts/%E9%80%9A%E8%BF%87babel-plugin%E6%A0%A1%E9%AA%8C%E5%B0%81%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84vue%E7%BB%84%E4%BB%B6/</id> <content src="chenng.cn/posts/%E9%80%9A%E8%BF%87babel-plugin%E6%A0%A1%E9%AA%8C%E5%B0%81%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84vue%E7%BB%84%E4%BB%B6/" /> <author> <name>chenng</name> </author> <summary> 之前就了解过 babel AST 相关的知识，刚好一个业务需求需要校验与修改第三方提供的 vue 组件，用 babel-plugin 来做这件事再合适不过了。 需求背景 三方提供互动的 vue 组件，如：https://m.v.qq.com/txi/dev 三方只编写基本的样式逻辑，最后需要在 vue 组件中注入默认 props、注入 mixins 提供与引擎通信的能力、并将 vue 组件挂在到 window._interactComps 下 预期结果 转换前的 vue 代码 Bubble.vue &amp;lt;style&amp;gt; .bubble { position: absolute; display: table; } &amp;lt;/style&amp;gt; &amp;lt;template&amp;gt; &amp;lt;div class="bubble" ... </summary> </entry> <entry><title>Telegram+rssbot搭建个人信息流服务</title><link href="chenng.cn/posts/Telegram+rssbot%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E6%B5%81%E6%9C%8D%E5%8A%A1/" rel="alternate" type="text/html" title="Telegram+rssbot搭建个人信息流服务" /><published>2020-04-12T00:00:00+08:00</published> <updated>2020-04-12T00:00:00+08:00</updated> <id>chenng.cn/posts/Telegram+rssbot%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E6%B5%81%E6%9C%8D%E5%8A%A1/</id> <content src="chenng.cn/posts/Telegram+rssbot%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E6%B5%81%E6%9C%8D%E5%8A%A1/" /> <author> <name>chenng</name> </author> <summary> 【即刻】走丢了很久，怀念她。想有一个渠道可以收敛日常生活中的所有通知，发现 Telegram 机器人配合 RSS 就很好的兼顾了阅读体验以及拓展支持，打开机器人对话框就能呈现一个完美的 Timeline。 方案：Telegram + 谷歌云 + flowerss-bot + RSSHub Telegram 机器人申请 在 Telegram 搜索 @BotFather，发送 /newbot 新建一个你的专属机器人，得到 token 后面会用到 申请谷歌云 因为网络通信原因，找了个可以白嫖的国外云服务厂商，首年免费，使用下来体验真的挺不错 https://console.cloud.google.com/?hl=zh-CN Compute Engine =&amp;gt; 虚拟机实例 =&amp;gt; 新建一个虚拟机，然后点击 ssh 登录上去 rssbot 服务启动（... </summary> </entry> </feed>
